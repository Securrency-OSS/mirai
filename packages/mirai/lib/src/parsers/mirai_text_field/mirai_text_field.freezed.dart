// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'mirai_text_field.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

MiraiTextField _$MiraiTextFieldFromJson(Map<String, dynamic> json) {
  return _MiraiTextField.fromJson(json);
}

/// @nodoc
mixin _$MiraiTextField {
  MiraiInputDecoration? get decoration => throw _privateConstructorUsedError;
  String get initialValue => throw _privateConstructorUsedError;
  MiraiTextInputType? get keyboardType => throw _privateConstructorUsedError;
  TextInputAction? get textInputAction => throw _privateConstructorUsedError;
  TextCapitalization get textCapitalization =>
      throw _privateConstructorUsedError;
  MiraiTextStyle? get style => throw _privateConstructorUsedError;
  TextAlign get textAlign => throw _privateConstructorUsedError;
  MiraiTextAlignVertical? get textAlignVertical =>
      throw _privateConstructorUsedError;
  TextDirection? get textDirection => throw _privateConstructorUsedError;
  bool get readOnly => throw _privateConstructorUsedError;
  bool? get showCursor => throw _privateConstructorUsedError;
  dynamic get expands => throw _privateConstructorUsedError;
  bool get autofocus => throw _privateConstructorUsedError;
  String get obscuringCharacter => throw _privateConstructorUsedError;
  int? get maxLines => throw _privateConstructorUsedError;
  int? get minLines => throw _privateConstructorUsedError;
  int? get maxLength => throw _privateConstructorUsedError;
  bool get obscureText => throw _privateConstructorUsedError;
  bool get enableSuggestions => throw _privateConstructorUsedError;
  bool? get enabled => throw _privateConstructorUsedError;
  double get cursorWidth => throw _privateConstructorUsedError;
  double? get cursorHeight => throw _privateConstructorUsedError;
  String? get cursorColor => throw _privateConstructorUsedError;
  String? get hintText => throw _privateConstructorUsedError;
  List<MiraiInputFormatter> get inputFormatters =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MiraiTextFieldCopyWith<MiraiTextField> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MiraiTextFieldCopyWith<$Res> {
  factory $MiraiTextFieldCopyWith(
          MiraiTextField value, $Res Function(MiraiTextField) then) =
      _$MiraiTextFieldCopyWithImpl<$Res, MiraiTextField>;
  @useResult
  $Res call(
      {MiraiInputDecoration? decoration,
      String initialValue,
      MiraiTextInputType? keyboardType,
      TextInputAction? textInputAction,
      TextCapitalization textCapitalization,
      MiraiTextStyle? style,
      TextAlign textAlign,
      MiraiTextAlignVertical? textAlignVertical,
      TextDirection? textDirection,
      bool readOnly,
      bool? showCursor,
      dynamic expands,
      bool autofocus,
      String obscuringCharacter,
      int? maxLines,
      int? minLines,
      int? maxLength,
      bool obscureText,
      bool enableSuggestions,
      bool? enabled,
      double cursorWidth,
      double? cursorHeight,
      String? cursorColor,
      String? hintText,
      List<MiraiInputFormatter> inputFormatters});

  $MiraiInputDecorationCopyWith<$Res>? get decoration;
  $MiraiTextStyleCopyWith<$Res>? get style;
}

/// @nodoc
class _$MiraiTextFieldCopyWithImpl<$Res, $Val extends MiraiTextField>
    implements $MiraiTextFieldCopyWith<$Res> {
  _$MiraiTextFieldCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? decoration = freezed,
    Object? initialValue = null,
    Object? keyboardType = freezed,
    Object? textInputAction = freezed,
    Object? textCapitalization = null,
    Object? style = freezed,
    Object? textAlign = null,
    Object? textAlignVertical = freezed,
    Object? textDirection = freezed,
    Object? readOnly = null,
    Object? showCursor = freezed,
    Object? expands = freezed,
    Object? autofocus = null,
    Object? obscuringCharacter = null,
    Object? maxLines = freezed,
    Object? minLines = freezed,
    Object? maxLength = freezed,
    Object? obscureText = null,
    Object? enableSuggestions = null,
    Object? enabled = freezed,
    Object? cursorWidth = null,
    Object? cursorHeight = freezed,
    Object? cursorColor = freezed,
    Object? hintText = freezed,
    Object? inputFormatters = null,
  }) {
    return _then(_value.copyWith(
      decoration: freezed == decoration
          ? _value.decoration
          : decoration // ignore: cast_nullable_to_non_nullable
              as MiraiInputDecoration?,
      initialValue: null == initialValue
          ? _value.initialValue
          : initialValue // ignore: cast_nullable_to_non_nullable
              as String,
      keyboardType: freezed == keyboardType
          ? _value.keyboardType
          : keyboardType // ignore: cast_nullable_to_non_nullable
              as MiraiTextInputType?,
      textInputAction: freezed == textInputAction
          ? _value.textInputAction
          : textInputAction // ignore: cast_nullable_to_non_nullable
              as TextInputAction?,
      textCapitalization: null == textCapitalization
          ? _value.textCapitalization
          : textCapitalization // ignore: cast_nullable_to_non_nullable
              as TextCapitalization,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as MiraiTextStyle?,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      textAlignVertical: freezed == textAlignVertical
          ? _value.textAlignVertical
          : textAlignVertical // ignore: cast_nullable_to_non_nullable
              as MiraiTextAlignVertical?,
      textDirection: freezed == textDirection
          ? _value.textDirection
          : textDirection // ignore: cast_nullable_to_non_nullable
              as TextDirection?,
      readOnly: null == readOnly
          ? _value.readOnly
          : readOnly // ignore: cast_nullable_to_non_nullable
              as bool,
      showCursor: freezed == showCursor
          ? _value.showCursor
          : showCursor // ignore: cast_nullable_to_non_nullable
              as bool?,
      expands: freezed == expands
          ? _value.expands
          : expands // ignore: cast_nullable_to_non_nullable
              as dynamic,
      autofocus: null == autofocus
          ? _value.autofocus
          : autofocus // ignore: cast_nullable_to_non_nullable
              as bool,
      obscuringCharacter: null == obscuringCharacter
          ? _value.obscuringCharacter
          : obscuringCharacter // ignore: cast_nullable_to_non_nullable
              as String,
      maxLines: freezed == maxLines
          ? _value.maxLines
          : maxLines // ignore: cast_nullable_to_non_nullable
              as int?,
      minLines: freezed == minLines
          ? _value.minLines
          : minLines // ignore: cast_nullable_to_non_nullable
              as int?,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      obscureText: null == obscureText
          ? _value.obscureText
          : obscureText // ignore: cast_nullable_to_non_nullable
              as bool,
      enableSuggestions: null == enableSuggestions
          ? _value.enableSuggestions
          : enableSuggestions // ignore: cast_nullable_to_non_nullable
              as bool,
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      cursorWidth: null == cursorWidth
          ? _value.cursorWidth
          : cursorWidth // ignore: cast_nullable_to_non_nullable
              as double,
      cursorHeight: freezed == cursorHeight
          ? _value.cursorHeight
          : cursorHeight // ignore: cast_nullable_to_non_nullable
              as double?,
      cursorColor: freezed == cursorColor
          ? _value.cursorColor
          : cursorColor // ignore: cast_nullable_to_non_nullable
              as String?,
      hintText: freezed == hintText
          ? _value.hintText
          : hintText // ignore: cast_nullable_to_non_nullable
              as String?,
      inputFormatters: null == inputFormatters
          ? _value.inputFormatters
          : inputFormatters // ignore: cast_nullable_to_non_nullable
              as List<MiraiInputFormatter>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MiraiInputDecorationCopyWith<$Res>? get decoration {
    if (_value.decoration == null) {
      return null;
    }

    return $MiraiInputDecorationCopyWith<$Res>(_value.decoration!, (value) {
      return _then(_value.copyWith(decoration: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MiraiTextStyleCopyWith<$Res>? get style {
    if (_value.style == null) {
      return null;
    }

    return $MiraiTextStyleCopyWith<$Res>(_value.style!, (value) {
      return _then(_value.copyWith(style: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MiraiTextFieldCopyWith<$Res>
    implements $MiraiTextFieldCopyWith<$Res> {
  factory _$$_MiraiTextFieldCopyWith(
          _$_MiraiTextField value, $Res Function(_$_MiraiTextField) then) =
      __$$_MiraiTextFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {MiraiInputDecoration? decoration,
      String initialValue,
      MiraiTextInputType? keyboardType,
      TextInputAction? textInputAction,
      TextCapitalization textCapitalization,
      MiraiTextStyle? style,
      TextAlign textAlign,
      MiraiTextAlignVertical? textAlignVertical,
      TextDirection? textDirection,
      bool readOnly,
      bool? showCursor,
      dynamic expands,
      bool autofocus,
      String obscuringCharacter,
      int? maxLines,
      int? minLines,
      int? maxLength,
      bool obscureText,
      bool enableSuggestions,
      bool? enabled,
      double cursorWidth,
      double? cursorHeight,
      String? cursorColor,
      String? hintText,
      List<MiraiInputFormatter> inputFormatters});

  @override
  $MiraiInputDecorationCopyWith<$Res>? get decoration;
  @override
  $MiraiTextStyleCopyWith<$Res>? get style;
}

/// @nodoc
class __$$_MiraiTextFieldCopyWithImpl<$Res>
    extends _$MiraiTextFieldCopyWithImpl<$Res, _$_MiraiTextField>
    implements _$$_MiraiTextFieldCopyWith<$Res> {
  __$$_MiraiTextFieldCopyWithImpl(
      _$_MiraiTextField _value, $Res Function(_$_MiraiTextField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? decoration = freezed,
    Object? initialValue = null,
    Object? keyboardType = freezed,
    Object? textInputAction = freezed,
    Object? textCapitalization = null,
    Object? style = freezed,
    Object? textAlign = null,
    Object? textAlignVertical = freezed,
    Object? textDirection = freezed,
    Object? readOnly = null,
    Object? showCursor = freezed,
    Object? expands = freezed,
    Object? autofocus = null,
    Object? obscuringCharacter = null,
    Object? maxLines = freezed,
    Object? minLines = freezed,
    Object? maxLength = freezed,
    Object? obscureText = null,
    Object? enableSuggestions = null,
    Object? enabled = freezed,
    Object? cursorWidth = null,
    Object? cursorHeight = freezed,
    Object? cursorColor = freezed,
    Object? hintText = freezed,
    Object? inputFormatters = null,
  }) {
    return _then(_$_MiraiTextField(
      decoration: freezed == decoration
          ? _value.decoration
          : decoration // ignore: cast_nullable_to_non_nullable
              as MiraiInputDecoration?,
      initialValue: null == initialValue
          ? _value.initialValue
          : initialValue // ignore: cast_nullable_to_non_nullable
              as String,
      keyboardType: freezed == keyboardType
          ? _value.keyboardType
          : keyboardType // ignore: cast_nullable_to_non_nullable
              as MiraiTextInputType?,
      textInputAction: freezed == textInputAction
          ? _value.textInputAction
          : textInputAction // ignore: cast_nullable_to_non_nullable
              as TextInputAction?,
      textCapitalization: null == textCapitalization
          ? _value.textCapitalization
          : textCapitalization // ignore: cast_nullable_to_non_nullable
              as TextCapitalization,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as MiraiTextStyle?,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      textAlignVertical: freezed == textAlignVertical
          ? _value.textAlignVertical
          : textAlignVertical // ignore: cast_nullable_to_non_nullable
              as MiraiTextAlignVertical?,
      textDirection: freezed == textDirection
          ? _value.textDirection
          : textDirection // ignore: cast_nullable_to_non_nullable
              as TextDirection?,
      readOnly: null == readOnly
          ? _value.readOnly
          : readOnly // ignore: cast_nullable_to_non_nullable
              as bool,
      showCursor: freezed == showCursor
          ? _value.showCursor
          : showCursor // ignore: cast_nullable_to_non_nullable
              as bool?,
      expands: freezed == expands ? _value.expands! : expands,
      autofocus: null == autofocus
          ? _value.autofocus
          : autofocus // ignore: cast_nullable_to_non_nullable
              as bool,
      obscuringCharacter: null == obscuringCharacter
          ? _value.obscuringCharacter
          : obscuringCharacter // ignore: cast_nullable_to_non_nullable
              as String,
      maxLines: freezed == maxLines
          ? _value.maxLines
          : maxLines // ignore: cast_nullable_to_non_nullable
              as int?,
      minLines: freezed == minLines
          ? _value.minLines
          : minLines // ignore: cast_nullable_to_non_nullable
              as int?,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      obscureText: null == obscureText
          ? _value.obscureText
          : obscureText // ignore: cast_nullable_to_non_nullable
              as bool,
      enableSuggestions: null == enableSuggestions
          ? _value.enableSuggestions
          : enableSuggestions // ignore: cast_nullable_to_non_nullable
              as bool,
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      cursorWidth: null == cursorWidth
          ? _value.cursorWidth
          : cursorWidth // ignore: cast_nullable_to_non_nullable
              as double,
      cursorHeight: freezed == cursorHeight
          ? _value.cursorHeight
          : cursorHeight // ignore: cast_nullable_to_non_nullable
              as double?,
      cursorColor: freezed == cursorColor
          ? _value.cursorColor
          : cursorColor // ignore: cast_nullable_to_non_nullable
              as String?,
      hintText: freezed == hintText
          ? _value.hintText
          : hintText // ignore: cast_nullable_to_non_nullable
              as String?,
      inputFormatters: null == inputFormatters
          ? _value._inputFormatters
          : inputFormatters // ignore: cast_nullable_to_non_nullable
              as List<MiraiInputFormatter>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MiraiTextField implements _MiraiTextField {
  const _$_MiraiTextField(
      {this.decoration,
      this.initialValue = '',
      this.keyboardType,
      this.textInputAction,
      this.textCapitalization = TextCapitalization.none,
      this.style,
      this.textAlign = TextAlign.start,
      this.textAlignVertical,
      this.textDirection,
      this.readOnly = false,
      this.showCursor,
      this.expands = false,
      this.autofocus = false,
      this.obscuringCharacter = 'â€¢',
      this.maxLines,
      this.minLines,
      this.maxLength,
      this.obscureText = false,
      this.enableSuggestions = true,
      this.enabled,
      this.cursorWidth = 2,
      this.cursorHeight,
      this.cursorColor,
      this.hintText,
      final List<MiraiInputFormatter> inputFormatters = const []})
      : _inputFormatters = inputFormatters;

  factory _$_MiraiTextField.fromJson(Map<String, dynamic> json) =>
      _$$_MiraiTextFieldFromJson(json);

  @override
  final MiraiInputDecoration? decoration;
  @override
  @JsonKey()
  final String initialValue;
  @override
  final MiraiTextInputType? keyboardType;
  @override
  final TextInputAction? textInputAction;
  @override
  @JsonKey()
  final TextCapitalization textCapitalization;
  @override
  final MiraiTextStyle? style;
  @override
  @JsonKey()
  final TextAlign textAlign;
  @override
  final MiraiTextAlignVertical? textAlignVertical;
  @override
  final TextDirection? textDirection;
  @override
  @JsonKey()
  final bool readOnly;
  @override
  final bool? showCursor;
  @override
  @JsonKey()
  final dynamic expands;
  @override
  @JsonKey()
  final bool autofocus;
  @override
  @JsonKey()
  final String obscuringCharacter;
  @override
  final int? maxLines;
  @override
  final int? minLines;
  @override
  final int? maxLength;
  @override
  @JsonKey()
  final bool obscureText;
  @override
  @JsonKey()
  final bool enableSuggestions;
  @override
  final bool? enabled;
  @override
  @JsonKey()
  final double cursorWidth;
  @override
  final double? cursorHeight;
  @override
  final String? cursorColor;
  @override
  final String? hintText;
  final List<MiraiInputFormatter> _inputFormatters;
  @override
  @JsonKey()
  List<MiraiInputFormatter> get inputFormatters {
    if (_inputFormatters is EqualUnmodifiableListView) return _inputFormatters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_inputFormatters);
  }

  @override
  String toString() {
    return 'MiraiTextField(decoration: $decoration, initialValue: $initialValue, keyboardType: $keyboardType, textInputAction: $textInputAction, textCapitalization: $textCapitalization, style: $style, textAlign: $textAlign, textAlignVertical: $textAlignVertical, textDirection: $textDirection, readOnly: $readOnly, showCursor: $showCursor, expands: $expands, autofocus: $autofocus, obscuringCharacter: $obscuringCharacter, maxLines: $maxLines, minLines: $minLines, maxLength: $maxLength, obscureText: $obscureText, enableSuggestions: $enableSuggestions, enabled: $enabled, cursorWidth: $cursorWidth, cursorHeight: $cursorHeight, cursorColor: $cursorColor, hintText: $hintText, inputFormatters: $inputFormatters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MiraiTextField &&
            (identical(other.decoration, decoration) ||
                other.decoration == decoration) &&
            (identical(other.initialValue, initialValue) ||
                other.initialValue == initialValue) &&
            (identical(other.keyboardType, keyboardType) ||
                other.keyboardType == keyboardType) &&
            (identical(other.textInputAction, textInputAction) ||
                other.textInputAction == textInputAction) &&
            (identical(other.textCapitalization, textCapitalization) ||
                other.textCapitalization == textCapitalization) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.textAlign, textAlign) ||
                other.textAlign == textAlign) &&
            (identical(other.textAlignVertical, textAlignVertical) ||
                other.textAlignVertical == textAlignVertical) &&
            (identical(other.textDirection, textDirection) ||
                other.textDirection == textDirection) &&
            (identical(other.readOnly, readOnly) ||
                other.readOnly == readOnly) &&
            (identical(other.showCursor, showCursor) ||
                other.showCursor == showCursor) &&
            const DeepCollectionEquality().equals(other.expands, expands) &&
            (identical(other.autofocus, autofocus) ||
                other.autofocus == autofocus) &&
            (identical(other.obscuringCharacter, obscuringCharacter) ||
                other.obscuringCharacter == obscuringCharacter) &&
            (identical(other.maxLines, maxLines) ||
                other.maxLines == maxLines) &&
            (identical(other.minLines, minLines) ||
                other.minLines == minLines) &&
            (identical(other.maxLength, maxLength) ||
                other.maxLength == maxLength) &&
            (identical(other.obscureText, obscureText) ||
                other.obscureText == obscureText) &&
            (identical(other.enableSuggestions, enableSuggestions) ||
                other.enableSuggestions == enableSuggestions) &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.cursorWidth, cursorWidth) ||
                other.cursorWidth == cursorWidth) &&
            (identical(other.cursorHeight, cursorHeight) ||
                other.cursorHeight == cursorHeight) &&
            (identical(other.cursorColor, cursorColor) ||
                other.cursorColor == cursorColor) &&
            (identical(other.hintText, hintText) ||
                other.hintText == hintText) &&
            const DeepCollectionEquality()
                .equals(other._inputFormatters, _inputFormatters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        decoration,
        initialValue,
        keyboardType,
        textInputAction,
        textCapitalization,
        style,
        textAlign,
        textAlignVertical,
        textDirection,
        readOnly,
        showCursor,
        const DeepCollectionEquality().hash(expands),
        autofocus,
        obscuringCharacter,
        maxLines,
        minLines,
        maxLength,
        obscureText,
        enableSuggestions,
        enabled,
        cursorWidth,
        cursorHeight,
        cursorColor,
        hintText,
        const DeepCollectionEquality().hash(_inputFormatters)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MiraiTextFieldCopyWith<_$_MiraiTextField> get copyWith =>
      __$$_MiraiTextFieldCopyWithImpl<_$_MiraiTextField>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MiraiTextFieldToJson(
      this,
    );
  }
}

abstract class _MiraiTextField implements MiraiTextField {
  const factory _MiraiTextField(
      {final MiraiInputDecoration? decoration,
      final String initialValue,
      final MiraiTextInputType? keyboardType,
      final TextInputAction? textInputAction,
      final TextCapitalization textCapitalization,
      final MiraiTextStyle? style,
      final TextAlign textAlign,
      final MiraiTextAlignVertical? textAlignVertical,
      final TextDirection? textDirection,
      final bool readOnly,
      final bool? showCursor,
      final dynamic expands,
      final bool autofocus,
      final String obscuringCharacter,
      final int? maxLines,
      final int? minLines,
      final int? maxLength,
      final bool obscureText,
      final bool enableSuggestions,
      final bool? enabled,
      final double cursorWidth,
      final double? cursorHeight,
      final String? cursorColor,
      final String? hintText,
      final List<MiraiInputFormatter> inputFormatters}) = _$_MiraiTextField;

  factory _MiraiTextField.fromJson(Map<String, dynamic> json) =
      _$_MiraiTextField.fromJson;

  @override
  MiraiInputDecoration? get decoration;
  @override
  String get initialValue;
  @override
  MiraiTextInputType? get keyboardType;
  @override
  TextInputAction? get textInputAction;
  @override
  TextCapitalization get textCapitalization;
  @override
  MiraiTextStyle? get style;
  @override
  TextAlign get textAlign;
  @override
  MiraiTextAlignVertical? get textAlignVertical;
  @override
  TextDirection? get textDirection;
  @override
  bool get readOnly;
  @override
  bool? get showCursor;
  @override
  dynamic get expands;
  @override
  bool get autofocus;
  @override
  String get obscuringCharacter;
  @override
  int? get maxLines;
  @override
  int? get minLines;
  @override
  int? get maxLength;
  @override
  bool get obscureText;
  @override
  bool get enableSuggestions;
  @override
  bool? get enabled;
  @override
  double get cursorWidth;
  @override
  double? get cursorHeight;
  @override
  String? get cursorColor;
  @override
  String? get hintText;
  @override
  List<MiraiInputFormatter> get inputFormatters;
  @override
  @JsonKey(ignore: true)
  _$$_MiraiTextFieldCopyWith<_$_MiraiTextField> get copyWith =>
      throw _privateConstructorUsedError;
}
